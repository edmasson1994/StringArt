<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color String Art Generator</title>
<style>
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        margin: 0;
        padding: 1rem;
        background-color: #f0f2f5;
        height: 100vh;
        box-sizing: border-box;
    }

    .container {
        display: flex;
        width: 90%;
        max-width: 1400px;
        background: #fff;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        height: 100%;
        margin: 0 auto;
    }

    .controls {
        flex: 1;
        padding: 1.5rem;
        border-right: 1px solid #ddd;
        min-width: 350px;
        overflow-y: auto;
    }

    .display {
        flex: 2;
        padding: 2rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        background-color: #f9f9f9;
        overflow-y: auto;
    }

    h2 {
        font-size: 1.1rem;
        margin-top: 0;
        margin-bottom: 1rem;
        color: #333;
        border-bottom: 1px solid #eee;
        padding-bottom: 0.5rem;
    }
    
    h3 {
        font-size: 1rem;
        margin-top: 1rem;
        margin-bottom: 0.75rem;
    }

    .control-group {
        margin-bottom: 1rem;
    }

    label {
        display: block;
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: #555;
        font-size: 0.85rem;
    }

    .slider-container {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.25rem;
    }

    .slider-container > label {
        width: 120px;
        flex-shrink: 0;
        margin-bottom: 0;
    }

    input[type="range"] {
        flex-grow: 1;
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 6px;
        background: #ddd;
        border-radius: 5px;
        outline: none;
        opacity: 0.7;
        transition: opacity .2s;
    }

    input[type="range"]:hover {
        opacity: 1;
    }

    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        background: #007bff;
        cursor: pointer;
        border-radius: 50%;
        border: 2px solid #fff;
        box-shadow: 0 0 2px rgba(0,0,0,0.3);
    }

    input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        background: #007bff;
        cursor: pointer;
        border-radius: 50%;
        border: 2px solid #fff;
        box-shadow: 0 0 2px rgba(0,0,0,0.3);
    }

    .slider-value {
        font-weight: 500;
        min-width: 40px;
        text-align: center;
        color: #333;
        background-color: #e9ecef;
        padding: 0.2rem;
        border-radius: 4px;
        font-size: 0.8rem;
        border: 1px solid #ddd;
        -moz-appearance: textfield; /* Firefox */
    }

    .slider-value::-webkit-outer-spin-button,
    .slider-value::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
    }

    .styled-select {
        flex-grow: 1;
        padding: 0.4rem;
        border-radius: 4px;
        border: 1px solid #ddd;
        background-color: #e9ecef;
        font-weight: 500;
        font-size: 0.8rem;
        color: #333;
    }

    .file-input-wrapper {
        position: relative;
        overflow: hidden;
        display: inline-block;
        cursor: pointer;
        padding: 0.6rem 1.2rem;
        background-color: #007bff;
        color: white;
        border-radius: 5px;
        font-weight: 600;
        text-align: center;
        transition: background-color 0.2s;
        width: 100%;
        box-sizing: border-box;
    }

    .file-input-wrapper:hover {
        background-color: #0056b3;
    }

    .file-input-wrapper input[type="file"] {
        position: absolute;
        left: 0;
        top: 0;
        opacity: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
    }

    canvas {
        border: 1px solid #ccc;
        border-radius: 50%;
        margin-bottom: 2rem;
        max-width: 100%;
        height: auto;
        cursor: grab;
    }

    canvas:active {
        cursor: grabbing;
    }

    button {
        width: 100%;
        padding: 0.6rem;
        font-size: 0.9rem;
        font-weight: 600;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s, color 0.2s;
        margin-top: 0.5rem;
    }

    #generateBtn {
        background-color: #28a745;
        color: white;
    }

    #generateBtn:hover:not(:disabled) {
        background-color: #218838;
    }

    #generateBtn:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
    }

    .download-buttons button {
        background-color: #6c757d;
        color: white;
    }

    .download-buttons button:hover {
        background-color: #5a6268;
    }

    #generation-progress-container {
        /* Hidden by default, shown during generation */
    }

    .progress-bar-wrapper {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 0.75rem;
    }

    #generationProgress {
        width: 100%;
        height: 12px;
    }
    
    .generation-buttons {
        display: flex;
        gap: 1rem;
    }

    .generation-buttons button {
        flex: 1; /* Make buttons take equal width */
    }

    #pauseResumeBtn {
        background-color: #ffc107;
        color: #212529;
    }
    #pauseResumeBtn:hover:not(:disabled) {
        background-color: #e0a800;
    }
    
    #stopBtn {
        background-color: #dc3545;
        color: white;
    }
    #stopBtn:hover:not(:disabled) {
        background-color: #c82333;
    }

    #validation-message {
        color: #dc3545;
        font-weight: 600;
        margin-top: 0.75rem;
        min-height: 20px;
    }

    #paletteDisplay {
        display: flex;
        gap: 8px;
        margin-top: 8px;
        flex-wrap: wrap;
    }

    .palette-swatch {
        width: 100%;
        height: 100%;
        border-radius: 4px;
        border: 1px solid #ccc;
    }

    .palette-swatch-container {
        position: relative;
        width: 24px;
        height: 24px;
    }

    .remove-swatch-btn {
        position: absolute;
        top: -6px;
        right: -6px;
        width: 16px;
        height: 16px;
        background-color: #dc3545;
        color: white;
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        line-height: 16px;
        font-weight: bold;
        text-align: center;
        cursor: pointer;
        z-index: 10;
    }

    .palette-swatch-container:hover .remove-swatch-btn {
        display: flex;
    }

    input[type="color"] {
        width: 100%;
        height: 40px;
        border: 1px solid #ddd;
        border-radius: 4px;
        cursor: pointer;
        padding: 0 5px;
        box-sizing: border-box;
    }

    #customPalettePickerContainer input[type="color"] {
        width: 40px;
        height: 40px;
        border: 1px solid #ddd;
        border-radius: 4px;
        cursor: pointer;
        padding: 0;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        background-color: transparent;
    }
    #customPalettePickerContainer input[type="color"]::-webkit-color-swatch-wrapper {
        padding: 0;
    }
    #customPalettePickerContainer input[type="color"]::-webkit-color-swatch {
        border: none;
        border-radius: 4px;
    }
    #customPalettePickerContainer input[type="color"]::-moz-color-swatch {
        border: none;
        border-radius: 4px;
    }

    #addCustomColorBtn {
        width: 30px;
        height: 30px;
        font-size: 1.5rem;
        font-weight: bold;
        padding: 0;
        line-height: 30px;
        flex-shrink: 0;
        background-color: #28a745;
        color: white;
    }

    #addCustomColorBtn:hover {
        background-color: #218838;
    }

    .compact-background-controls {
        display: flex;
        gap: 0.5rem;
        align-items: stretch;
    }
    .compact-background-controls input[type="color"] {
        flex: 0 0 50px; /* Don't grow, don't shrink, base width 50px */
        height: auto;
        padding: 0 2px;
        min-height: 34px; /* Align with buttons */
    }
    .compact-background-controls button {
        flex: 1;
    }

    @media (max-width: 1200px) {
        .container {
            flex-direction: column;
            width: 95%;
            height: auto; /* Allow container to grow on small screens */
        }
        .controls {
            border-right: none;
            border-bottom: 1px solid #ddd;
        }
    }
</style>
</head>
<body>
<div class="container">
    <div class="controls">
        <h2>Controls</h2>
        <div class="control-group">
            <div class="file-input-wrapper">
                Browse Image
                <input type="file" id="imageLoader" accept="image/*">
            </div>
        </div>
        <div class="control-group">
            <h3>Image Settings</h3>
            <div class="slider-container">
                <label for="brightness">Brightness</label>
                <input type="range" id="brightness" min="0" max="200" value="100">
                <input type="number" class="slider-value" id="brightnessValue" min="0" max="200" value="100">
            </div>
            <div class="slider-container">
                <label for="contrast">Contrast</label>
                <input type="range" id="contrast" min="0" max="200" value="100">
                <input type="number" class="slider-value" id="contrastValue" min="0" max="200" value="100">
            </div>
            <div class="slider-container">
                <label for="saturation">Saturation</label>
                <input type="range" id="saturation" min="0" max="200" value="100">
                <input type="number" class="slider-value" id="saturationValue" min="0" max="200" value="100">
            </div>
        </div>
        <div class="control-group">
            <h3>String Art Parameters</h3>
            <div class="slider-container">
                <label for="resolution">Resolution</label>
                <select id="resolution" class="styled-select">
                    <option value="250">250x250 (Fast)</option>
                    <option value="500" selected>500x500 (Standard)</option>
                    <option value="750">750x750 (High)</option>
                    <option value="1000">1000x1000 (Ultra)</option>
                </select>
            </div>
            <div class="slider-container">
                <label for="pins">Number of Pins</label>
                <input type="range" id="pins" min="60" max="480" value="240">
                <input type="number" class="slider-value" id="pinsValue" min="60" max="480" value="240">
            </div>
            <div class="slider-container">
                <label for="lines">Number of Lines</label>
                <input type="range" id="lines" min="250" max="10000" value="5000">
                <input type="number" class="slider-value" id="linesValue" min="250" value="5000">
            </div>
            <div class="slider-container">
                <label for="pinDiameter">Pin Diameter (mm)</label>
                <input type="range" id="pinDiameter" min="0.5" max="5" step="0.1" value="2">
                <input type="number" class="slider-value" id="pinDiameterValue" min="0.5" max="5" step="0.1" value="2">
            </div>
            <div class="slider-container">
                <label for="opacity">Line Opacity</label>
                <input type="range" id="opacity" min="1" max="100" value="20">
                <input type="number" class="slider-value" id="opacityValue" min="1" max="100" value="20">
            </div>
            <div class="slider-container">
                <label for="minPinDistance">Min Pin Distance</label>
                <input type="range" id="minPinDistance" min="0" max="120" value="30">
                <input type="number" class="slider-value" id="minPinDistanceValue" min="0" max="120" value="30">
            </div>
            <div class="slider-container">
                <label for="monoLines">Monochromatic Lines</label>
                <input type="range" id="monoLines" min="0" max="10000" value="1000">
                <input type="number" class="slider-value" id="monoLinesValue" min="0" value="1000">
            </div>
        </div>
        <div class="control-group">
            <h3>Color Forcing</h3>
            <div class="slider-container">
                <label for="colorForcingEnabled">Enable Color Forcing</label>
                <input type="checkbox" id="colorForcingEnabled" style="width: 20px; height: 20px; flex-grow: 0;">
            </div>
            <div id="colorForcingControls" style="display: none; margin-top: 1rem;">
                <div class="slider-container">
                    <label for="colorForcingPercentage">Forcing Percentage</label>
                    <input type="range" id="colorForcingPercentage" min="0" max="100" value="20">
                    <input type="number" class="slider-value" id="colorForcingPercentageValue" min="0" max="100" value="20">
                </div>
                <!-- NEW: RGB Dominance Threshold -->
                <div class="slider-container">
                    <label for="dominanceThreshold">RGB Dominance Threshold</label>
                    <input type="range" id="dominanceThreshold" min="0" max="255" value="30">
                    <input type="number" class="slider-value" id="dominanceThresholdValue" min="0" max="255" value="30">
                </div>
            </div>
        </div>
        <div class="control-group">
            <h3>Central Pin</h3>
            <div class="slider-container">
                <label for="centralPinEnabled">Enable Central Pin</label>
                <input type="checkbox" id="centralPinEnabled" style="width: 20px; height: 20px; flex-grow: 0;" checked>
            </div>
            <div id="centralPinControls" style="display: none; margin-top: 1rem;">
            </div>
        </div>
        <div class="control-group">
            <h3>Middle Pins</h3>
            <div class="slider-container">
                <label for="middlePinsEnabled">Enable Middle Pins</label>
                <input type="checkbox" id="middlePinsEnabled" style="width: 20px; height: 20px; flex-grow: 0;" checked>
            </div>
            <div id="middlePinControls" style="display: none; margin-top: 1rem;">
                <div class="slider-container">
                    <label for="middlePins">Number of Middle Pins</label>
                    <input type="range" id="middlePins" min="3" max="16" value="16">
                    <input type="number" class="slider-value" id="middlePinsValue" min="3" max="16" value="16">
                </div>
            </div>
        </div>
        <div class="control-group">
            <h3>Background Color</h3>
            <div class="compact-background-controls">
                <input type="color" id="backgroundColorPicker" value="#FFFFFF" title="Manual Background Color">
                <button id="analyzeBinnedBtn">Binned</button>
                <button id="analyzeAverageBtn">Average</button>
            </div>
            <div id="binnedPrecisionText" style="font-size: 0.75rem; color: #666; text-align: center; min-height: 1em; margin-top: 0.25rem;"></div>
        </div>
        <div class="control-group">
            <h3>Thread Palette</h3>
            <div class="slider-container">
                <label for="paletteMode">Palette Type</label>
                <select id="paletteMode" class="styled-select">
                    <option value="classic">Classic (RGBKW)</option>
                    <option value="extended-classic" selected>Extended Classic</option>
                    <option value="vibrant">Vibrant</option>
                    <option value="super-extended">Super Extended</option>
                    <option value="low-saturation">Low Saturation</option>
                    <option value="greyscale">Greyscale (7 shades)</option>
                    <option value="smart">Smart Palette (from Image)</option>
                    <option value="smart-lines">Smart Palette (Line-based)</option>
                    <option value="custom">Custom</option>
                    <option value="black-white">Black & White</option>
                    <option value="black">Black Only</option>
                    <option value="white">White Only</option>
                </select>
            </div>
            <div id="smartPaletteControls" style="display: none;">
                <div class="slider-container">
                    <label for="paletteColors">Num Colors</label>
                    <input type="range" id="paletteColors" min="2" max="10" value="5">
                    <input type="number" class="slider-value" id="paletteColorsValue" min="2" max="10" value="5">
                </div>
                <div id="foregroundSeparationControl">
                    <div class="slider-container">
                        <label for="foregroundThreshold">Foreground Separation</label>
                        <input type="range" id="foregroundThreshold" min="0" max="150" value="50">
                        <input type="number" class="slider-value" id="foregroundThresholdValue" min="0" max="150" value="50">
                    </div>
                </div>
                <button id="analyzePaletteBtn" style="margin-top: 1rem;">Analyze Palette from Image</button>
                <div id="palette-display-container" style="margin-top: 1rem;">
                    <label>Generated Palette:</label>
                    <div id="paletteDisplay"></div>
                </div>
            </div>
            <div id="customPaletteControls" style="display: none;">
                 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
                    <label style="margin-bottom: 0;">Custom Colors</label>
                    <button id="addCustomColorBtn" title="Add New Color">+</button>
                </div>
                <div id="customPalettePickerContainer" style="margin-top: 1rem; display: flex; flex-wrap: wrap; gap: 10px;">
                    <!-- Color pickers generated by JS -->
                </div>
            </div>
        </div>
        <div class="control-group">
            <button id="generateBtn">Generate</button>
            <div id="validation-message"></div>
        </div>
        <div id="generation-progress-container" class="control-group" style="display: none;">
            <div class="progress-bar-wrapper">
                <progress id="generationProgress" value="0"></progress>
                <span id="progressText" class="slider-value">0 / 0</span>
            </div>
            <div class="generation-buttons">
                <button id="pauseResumeBtn">Pause</button>
                <button id="stopBtn">Stop</button>
            </div>
        </div>
        <div class="control-group download-buttons">
            <button id="downloadResultsBtn">Download Results</button>
        </div>
    </div>
    <div class="display">
        <canvas id="sourceCanvas"></canvas>
        <canvas id="previewCanvas"></canvas>
        <div id="statsContainer" style="display: none; width: 100%; margin-top: 1rem; flex-direction: column; align-items: center;">
            <div id="similarityDisplay" style="text-align: center; font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem;">
                Similarity: <span id="similarityScore">N/A</span>
            </div>
            <canvas id="similarityGraphCanvas" style="height: 150px; border: 1px solid #ccc; border-radius: 4px; width: 100%;"></canvas>
        </div>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const imageLoader = document.getElementById('imageLoader');
    const sourceCanvas = document.getElementById('sourceCanvas');
    const previewCanvas = document.getElementById('previewCanvas');
    const sourceCtx = sourceCanvas.getContext('2d');
    const previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });
    const resolutionSelector = document.getElementById('resolution');
    const backgroundColorPicker = document.getElementById('backgroundColorPicker');

    const sliders = {
        brightness: document.getElementById('brightness'),
        contrast: document.getElementById('contrast'),
        saturation: document.getElementById('saturation'),
        pins: document.getElementById('pins'),
        lines: document.getElementById('lines'),
        opacity: document.getElementById('opacity'),
        pinDiameter: document.getElementById('pinDiameter'),
        minPinDistance: document.getElementById('minPinDistance'),
        monoLines: document.getElementById('monoLines'),
    };

    const sliderValues = {
        brightness: document.getElementById('brightnessValue'),
        contrast: document.getElementById('contrastValue'),
        saturation: document.getElementById('saturationValue'),
        pins: document.getElementById('pinsValue'),
        lines: document.getElementById('linesValue'),
        opacity: document.getElementById('opacityValue'),
        pinDiameter: document.getElementById('pinDiameterValue'),
        minPinDistance: document.getElementById('minPinDistanceValue'),
        monoLines: document.getElementById('monoLinesValue'),
    };
    
    const generateBtn = document.getElementById('generateBtn');
    const downloadResultsBtn = document.getElementById('downloadResultsBtn');
    const generationProgressContainer = document.getElementById('generation-progress-container');
    const generationProgress = document.getElementById('generationProgress');
    const progressText = document.getElementById('progressText');
    const pauseResumeBtn = document.getElementById('pauseResumeBtn');
    const stopBtn = document.getElementById('stopBtn');
    const validationMessage = document.getElementById('validation-message');

    // New Color Analysis DOM Elements
    const paletteModeSelector = document.getElementById('paletteMode');
    const smartPaletteControls = document.getElementById('smartPaletteControls');
    const paletteColorsSlider = document.getElementById('paletteColors');
    const paletteColorsValue = document.getElementById('paletteColorsValue');
    const analyzePaletteBtn = document.getElementById('analyzePaletteBtn');
    const analyzeBinnedBtn = document.getElementById('analyzeBinnedBtn');
    const analyzeAverageBtn = document.getElementById('analyzeAverageBtn');
    const binnedPrecisionText = document.getElementById('binnedPrecisionText');
    const paletteDisplay = document.getElementById('paletteDisplay');
    const foregroundThresholdSlider = document.getElementById('foregroundThreshold');
    const foregroundThresholdValue = document.getElementById('foregroundThresholdValue');
    const foregroundSeparationControl = document.getElementById('foregroundSeparationControl');

    // Custom Palette DOM elements
    const customPaletteControls = document.getElementById('customPaletteControls');
    const addCustomColorBtn = document.getElementById('addCustomColorBtn');
    const customPalettePickerContainer = document.getElementById('customPalettePickerContainer');

    // Central Pin DOM elements
    const centralPinEnabledCheckbox = document.getElementById('centralPinEnabled');
    const centralPinControls = document.getElementById('centralPinControls');

    // Middle Pin DOM elements
    const middlePinsEnabledCheckbox = document.getElementById('middlePinsEnabled');
    const middlePinControls = document.getElementById('middlePinControls');
    const middlePinsSlider = document.getElementById('middlePins');
    const middlePinsValue = document.getElementById('middlePinsValue');

    // Stats and Graph DOM elements
    const statsContainer = document.getElementById('statsContainer');
    const similarityScore = document.getElementById('similarityScore');
    const similarityGraphCanvas = document.getElementById('similarityGraphCanvas');
    const similarityGraphCtx = similarityGraphCanvas.getContext('2d');

    // Color Forcing DOM elements
    const colorForcingEnabledCheckbox = document.getElementById('colorForcingEnabled');
    const colorForcingControls = document.getElementById('colorForcingControls');
    const colorForcingPercentageSlider = document.getElementById('colorForcingPercentage');
    const colorForcingPercentageValue = document.getElementById('colorForcingPercentageValue');
    const dominanceThresholdSlider = document.getElementById('dominanceThreshold');
    const dominanceThresholdValue = document.getElementById('dominanceThresholdValue');
    
    // --- State Variables ---
    let sourceImage = null;
    let imageTransform = { scale: 1, pos: { x: 0, y: 0 } };
    let isPanning = false;
    let startPan = { x: 0, y: 0 };
    let pinSequence = [];
    let similarityHistory = [];
    let connectionPoints = [];
    let processedImageCanvas = null; // Offscreen canvas for the processed image
    let processingScheduled = false; // For throttling slider updates
    
    let isGenerating = false;
    let isPaused = false;
    let stopGeneration = false;
    let hasGenerated = false; // To track if a generation has run
    let totalStringLengthMm = 0;
    let currentResolution = 500;
    let currentBackgroundColor = '#FFFFFF';
    let activePalette = []; // Holds [[r,g,b], ...] for smart palette
    let isCentralPinEnabled = false;
    let areMiddlePinsEnabled = false;
    let isColorForcingEnabled = false;
    let binnedBackgroundPrecision = 1;

    const classicThreads = [ // The classic palette
        { name: 'R', color: [255, 0, 0] },
        { name: 'G', color: [0, 255, 0] },
        { name: 'B', color: [0, 0, 255] },
        { name: 'K', color: [0, 0, 0] },
        { name: 'W', color: [255, 255, 255] }
    ];

    const extendedClassicThreads = [
        { name: 'R', color: [255, 0, 0] },
        { name: 'DR', color: [128, 0, 0] },
        { name: 'LR', color: [255, 128, 128] },
        { name: 'G', color: [0, 255, 0] },
        { name: 'DG', color: [0, 128, 0] },
        { name: 'LG', color: [128, 255, 128] },
        { name: 'B', color: [0, 0, 255] },
        { name: 'DB', color: [0, 0, 128] },
        { name: 'LB', color: [128, 128, 255] },
        { name: 'K', color: [0, 0, 0] },
        { name: 'W', color: [255, 255, 255] }
    ];

    const blackAndWhiteThreads = [
        { name: 'K', color: [0, 0, 0] },
        { name: 'W', color: [255, 255, 255] }
    ];

    const blackThreads = [ { name: 'K', color: [0, 0, 0] } ];
    const whiteThreads = [ { name: 'W', color: [255, 255, 255] } ];

    const lowSaturationThreads = [
        { name: 'R-L',  color: hslToRgb(0, 30, 50) },
        { name: 'R-VL', color: hslToRgb(0, 20, 50) },
        { name: 'R-VVL',color: hslToRgb(0, 10, 50) },
        { name: 'G-L',  color: hslToRgb(120, 30, 50) },
        { name: 'G-VL', color: hslToRgb(120, 20, 50) },
        { name: 'G-VVL',color: hslToRgb(120, 10, 50) },
        { name: 'B-L',  color: hslToRgb(240, 30, 50) },
        { name: 'B-VL', color: hslToRgb(240, 20, 50) },
        { name: 'B-VVL',color: hslToRgb(240, 10, 50) },
        { name: 'K', color: [0, 0, 0] },
        { name: 'G', color: [128, 128, 128] },
        { name: 'W', color: [255, 255, 255] }
    ];

    const superExtendedThreads = (() => {
        const threads = [];
        const hues = { 'R': 0, 'G': 120, 'B': 240 };
        const lightnessLevels = { 'D': 25, 'M': 50, 'H': 75 }; // Dark, Medium, High
        const saturationLevels = { 'L': 33, 'M': 66, 'H': 100 }; // Low, Med, High

        for (const [colorName, hue] of Object.entries(hues)) {
            for (const [lightName, light] of Object.entries(lightnessLevels)) {
                for (const [satName, sat] of Object.entries(saturationLevels)) {
                    threads.push({
                        name: `${colorName}-${lightName}${satName}`,
                        color: hslToRgb(hue, sat, light)
                    });
                }
            }
        }
        // Add greyscale
        threads.push({ name: 'K', color: [0, 0, 0] });
        threads.push({ name: 'G1', color: [64, 64, 64] });
        threads.push({ name: 'G2', color: [128, 128, 128] });
        threads.push({ name: 'G3', color: [192, 192, 192] });
        threads.push({ name: 'W', color: [255, 255, 255] });
        return threads;
    })();

    const greyscaleThreads = [
        { name: 'K',  color: [0, 0, 0] },
        { name: 'G1', color: [43, 43, 43] },
        { name: 'G2', color: [85, 85, 85] },
        { name: 'G3', color: [128, 128, 128] },
        { name: 'G4', color: [170, 170, 170] },
        { name: 'G5', color: [213, 213, 213] },
        { name: 'W',  color: [255, 255, 255] }
    ];

    const vibrantThreads = [
        { name: 'R', color: [255, 0, 0] },
        { name: 'G', color: [0, 255, 0] },
        { name: 'B', color: [0, 0, 255] },
        { name: 'K', color: [0, 0, 0] },
        { name: 'W', color: [255, 255, 255] },
        { name: 'O', color: [255, 165, 0] },   // Orange
        { name: 'P', color: [128, 0, 128] },    // Purple
        { name: 'Y', color: [255, 255, 0] },    // Yellow
        { name: 'T', color: [64, 224, 208] },  // Turquoise
        { name: 'PK', color: [255, 192, 203] } // Pink
    ];

    function hslToRgb(h, s, l) {
        s /= 100;
        l /= 100;
        let c = (1 - Math.abs(2 * l - 1)) * s,
            x = c * (1 - Math.abs((h / 60) % 2 - 1)),
            m = l - c / 2,
            r = 0,
            g = 0,
            b = 0;
        if (0 <= h && h < 60) {
            r = c; g = x; b = 0;
        } else if (60 <= h && h < 120) {
            r = x; g = c; b = 0;
        } else if (120 <= h && h < 180) {
            r = 0; g = c; b = x;
        } else if (180 <= h && h < 240) {
            r = 0; g = x; b = c;
        } else if (240 <= h && h < 300) {
            r = x; g = 0; b = c;
        } else if (300 <= h && h < 360) {
            r = c; g = 0; b = x;
        }
        r = Math.round((r + m) * 255);
        g = Math.round((g + m) * 255);
        b = Math.round((b + m) * 255);
        return [r, g, b];
    }

    // --- Initial Setup ---
    function initializeCanvases() {
        const w = sourceCanvas.width;
        const h = sourceCanvas.height;
        
        sourceCtx.fillStyle = '#ddd';
        sourceCtx.fillRect(0, 0, w, h);
        sourceCtx.font = "16px Arial";
        sourceCtx.fillStyle = "#888";
        sourceCtx.textAlign = "center";
        sourceCtx.fillText("Upload an image to begin", w / 2, h / 2);

        // Set initial state from controls
        isCentralPinEnabled = centralPinEnabledCheckbox.checked;
        areMiddlePinsEnabled = middlePinsEnabledCheckbox.checked;
        isColorForcingEnabled = colorForcingEnabledCheckbox.checked;
        centralPinControls.style.display = isCentralPinEnabled ? 'block' : 'none';
        middlePinControls.style.display = areMiddlePinsEnabled ? 'block' : 'none';
        colorForcingControls.style.display = isColorForcingEnabled ? 'block' : 'none';

        updatePreviewBackground();
        validatePinLayout();
        updatePaletteDisplay(activePalette);
        updateBinnedPrecisionText();
        updateCustomPalettePickers();
    }

    // --- Event Listeners ---
    resolutionSelector.addEventListener('change', (e) => {
        const newSize = parseInt(e.target.value, 10);

        if (hasGenerated) {
            const confirmed = confirm("Changing the resolution will clear the generated artwork. Are you sure you want to continue?");
            if (confirmed) {
                hasGenerated = false; 
                pinSequence = []; 
                updateResolution(newSize);
            } else {
                e.target.value = currentResolution; // Revert dropdown
                return;
            }
        } else {
            updateResolution(newSize);
        }
    });

    backgroundColorPicker.addEventListener('input', () => {
        const newColor = backgroundColorPicker.value;
        if (hasGenerated) {
            const confirmed = confirm("Changing the background color will clear the generated artwork. Are you sure you want to continue?");
            if (confirmed) {
                hasGenerated = false;
                pinSequence = [];
                currentBackgroundColor = newColor;
                updatePreviewBackgroundAndPins();
            } else {
                backgroundColorPicker.value = currentBackgroundColor; // Revert picker
                return;
            }
        } else {
            currentBackgroundColor = newColor;
            updatePreviewBackground();
        }
    });

    function updateBinnedPrecisionText() {
        if(binnedPrecisionText) {
            binnedPrecisionText.textContent = `Binned precision: ${binnedBackgroundPrecision}/10`;
        }
    }

    function updateResolution(newSize) {
        currentResolution = newSize;
        resolutionSelector.value = newSize;

        sourceCanvas.width = newSize;
        sourceCanvas.height = newSize;
        previewCanvas.width = newSize;
        previewCanvas.height = newSize;
        similarityGraphCanvas.width = newSize;

        initializeCanvases(); 
        
        if (sourceImage) {
            // Re-create the processed canvas at the new size
            processedImageCanvas = document.createElement('canvas');
            processedImageCanvas.width = newSize;
            processedImageCanvas.height = newSize;
            processImageAndRedraw(); // Re-process and draw the image
        }
    }

    imageLoader.addEventListener('change', e => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = event => {
                sourceImage = new Image();
                sourceImage.onload = () => {
                    resetImageSettings();

                    const canvasSize = sourceCanvas.width;
                    // To fill the circle, we use the max scale factor, which will crop the image if needed.
                    const scale = Math.max(canvasSize / sourceImage.width, canvasSize / sourceImage.height);
                    const initialX = (canvasSize / scale - sourceImage.width) / 2;
                    const initialY = (canvasSize / scale - sourceImage.height) / 2;
                    
                    imageTransform = {
                        scale: scale,
                        pos: { x: initialX, y: initialY }
                    };

                    processedImageCanvas = document.createElement('canvas');
                    processedImageCanvas.width = sourceCanvas.width;
                    processedImageCanvas.height = sourceCanvas.height;
                    processImageAndRedraw();
                };
                sourceImage.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    Object.keys(sliders).forEach(key => {
        sliders[key].addEventListener('input', () => {
            sliderValues[key].value = sliders[key].value;
            // For image settings, throttle the expensive redraw using requestAnimationFrame
            if (sourceImage && ['brightness', 'contrast', 'saturation'].includes(key)) {
                 if (!processingScheduled) {
                    processingScheduled = true;
                    requestAnimationFrame(() => {
                        processImageAndRedraw();
                        processingScheduled = false;
                    });
                }
            }
        });
    });

    Object.keys(sliderValues).forEach(key => {
        sliderValues[key].addEventListener('change', (e) => {
            const slider = sliders[key];
            let value = (key === 'pinDiameter') ? parseFloat(e.target.value) : parseInt(e.target.value, 10);
            
            if (key === 'lines') {
                const min = parseInt(slider.min, 10);

                if (isNaN(value)) { // If not a number, revert to slider's last value.
                    value = slider.value;
                } else if (value < min) { // If below min, clamp to min.
                    value = min;
                }
                
                // If the new value is bigger than the slider's max, update the slider's max
                if (value > parseInt(slider.max, 10)) {
                    slider.max = value;
                }

            } else { // Original logic for all other sliders
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);

                if (isNaN(value)) {
                    value = slider.value;
                }
                if (value < min) {
                    value = min;
                }
                if (value > max) {
                    value = max;
                }
            }
            
            e.target.value = value;
            slider.value = value;

            // Manually trigger input event on slider to trigger redraw etc.
            slider.dispatchEvent(new Event('input'));
        });
        
        sliderValues[key].addEventListener('focus', e => e.target.select());
    });

    function updateMonoLinesSliderMax() {
        const numLines = parseInt(sliders.lines.value, 10);
        const monoSlider = sliders.monoLines;
        const monoValue = sliderValues.monoLines;
        
        monoSlider.max = numLines;
        monoValue.max = numLines;

        if (parseInt(monoSlider.value, 10) > numLines) {
            monoSlider.value = numLines;
            monoValue.value = numLines;
        }
    }

    sliders.lines.addEventListener('input', updateMonoLinesSliderMax);
    sliderValues.lines.addEventListener('change', updateMonoLinesSliderMax);

    ['pins', 'pinDiameter'].forEach(key => {
        sliders[key]?.addEventListener('input', validatePinLayout);
        sliderValues[key]?.addEventListener('change', validatePinLayout);
    });

    centralPinEnabledCheckbox.addEventListener('change', (e) => {
        isCentralPinEnabled = e.target.checked;
        centralPinControls.style.display = isCentralPinEnabled ? 'block' : 'none';
        updatePreviewBackgroundAndPins();
    });

    middlePinsEnabledCheckbox.addEventListener('change', (e) => {
        areMiddlePinsEnabled = e.target.checked;
        middlePinControls.style.display = areMiddlePinsEnabled ? 'block' : 'none';
        updatePreviewBackgroundAndPins();
    });

    middlePinsSlider.addEventListener('input', () => {
        middlePinsValue.value = middlePinsSlider.value;
        updatePreviewBackgroundAndPins();
    });

    middlePinsValue.addEventListener('change', (e) => {
        let value = parseInt(e.target.value, 10);
        const min = parseInt(middlePinsSlider.min, 10);
        const max = parseInt(middlePinsSlider.max, 10);
        if (isNaN(value)) value = middlePinsSlider.value;
        if (value < min) value = min;
        if (value > max) value = max;
        e.target.value = value;
        middlePinsSlider.value = value;
        updatePreviewBackgroundAndPins();
    });
    middlePinsValue.addEventListener('focus', e => e.target.select());

    colorForcingEnabledCheckbox.addEventListener('change', (e) => {
        isColorForcingEnabled = e.target.checked;
        colorForcingControls.style.display = isColorForcingEnabled ? 'block' : 'none';
    });

    colorForcingPercentageSlider.addEventListener('input', () => {
        colorForcingPercentageValue.value = colorForcingPercentageSlider.value;
    });

    colorForcingPercentageValue.addEventListener('change', (e) => {
        let value = parseInt(e.target.value, 10);
        const min = parseInt(colorForcingPercentageSlider.min, 10);
        const max = parseInt(colorForcingPercentageSlider.max, 10);
        if (isNaN(value)) value = colorForcingPercentageSlider.value;
        if (value < min) value = min;
        if (value > max) value = max;
        e.target.value = value;
        colorForcingPercentageSlider.value = value;
    });
    colorForcingPercentageValue.addEventListener('focus', e => e.target.select());

    // Dominance Threshold syncing
    dominanceThresholdSlider.addEventListener('input', () => {
        dominanceThresholdValue.value = dominanceThresholdSlider.value;
    });

    dominanceThresholdValue.addEventListener('change', (e) => {
        let value = parseInt(e.target.value, 10);
        const min = parseInt(dominanceThresholdSlider.min, 10);
        const max = parseInt(dominanceThresholdSlider.max, 10);
        if (isNaN(value)) value = dominanceThresholdSlider.value;
        if (value < min) value = min;
        if (value > max) value = max;
        e.target.value = value;
        dominanceThresholdSlider.value = value;
    });
    dominanceThresholdValue.addEventListener('focus', e => e.target.select());

    function validatePinLayout() {
        const numPins = parseInt(sliders.pins.value, 10);
        const pinDiameter = parseFloat(sliders.pinDiameter.value);
        const artDiameterMm = 400; // Fixed 40cm diameter
        const artCircumferenceMm = artDiameterMm * Math.PI;
        const totalPinWidthMm = numPins * pinDiameter;

        if (totalPinWidthMm >= artCircumferenceMm) {
            generateBtn.disabled = true;
            validationMessage.textContent = 'Pins won\'t fit. Reduce pin number or diameter.';
        } else {
            if (!isGenerating) { // Only enable if not already disabled by generation
                generateBtn.disabled = false;
            }
            validationMessage.textContent = '';
        }
    }

    function resetImageSettings() {
        const imageSettingKeys = ['brightness', 'contrast', 'saturation'];
        imageSettingKeys.forEach(key => {
            if (sliders[key]) {
                sliders[key].value = 100;
                sliderValues[key].value = '100';
            }
        });
    }
    
    sourceCanvas.addEventListener('mousedown', e => {
        if (!sourceImage) return;
        isPanning = true;
        startPan = { x: e.clientX, y: e.clientY };
        sourceCanvas.style.cursor = 'grabbing';
    });

    sourceCanvas.addEventListener('mouseup', () => {
        if (!sourceImage) return;
        isPanning = false;
        sourceCanvas.style.cursor = 'grab';
    });

    sourceCanvas.addEventListener('mouseleave', () => {
        if(isPanning) {
           isPanning = false;
           sourceCanvas.style.cursor = 'grab';
        }
    });
    
    sourceCanvas.addEventListener('mousemove', e => {
        if (isPanning && sourceImage) {
            const dx = e.clientX - startPan.x;
            const dy = e.clientY - startPan.y;
            imageTransform.pos.x += dx / imageTransform.scale;
            imageTransform.pos.y += dy / imageTransform.scale;
            startPan = { x: e.clientX, y: e.clientY };
            if (!processingScheduled) {
                processingScheduled = true;
                requestAnimationFrame(() => {
                    processImageAndRedraw();
                    processingScheduled = false;
                });
            }
        }
    });

    sourceCanvas.addEventListener('wheel', e => {
        if (!sourceImage) return;
        e.preventDefault();
        const rect = sourceCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const zoomFactor = 1.05;
        const oldScale = imageTransform.scale;
        
        imageTransform.scale *= (e.deltaY < 0 ? zoomFactor : 1 / zoomFactor);

        // Adjust position to zoom towards the mouse pointer
        imageTransform.pos.x = mouseX / imageTransform.scale - (mouseX / oldScale - imageTransform.pos.x);
        imageTransform.pos.y = mouseY / imageTransform.scale - (mouseY / oldScale - imageTransform.pos.y);

        if (!processingScheduled) {
            processingScheduled = true;
            requestAnimationFrame(() => {
                processImageAndRedraw();
                processingScheduled = false;
            });
        }
    });

    generateBtn.addEventListener('click', generateArt);
    downloadResultsBtn.addEventListener('click', downloadResults);
    
    pauseResumeBtn.addEventListener('click', () => {
        isPaused = !isPaused;
        pauseResumeBtn.textContent = isPaused ? 'Resume' : 'Pause';
    });

    stopBtn.addEventListener('click', () => {
        if (isGenerating) {
            stopGeneration = true;
            isPaused = false; // Break pause loop to enact stop
        }
    });

    // --- Color Analysis Listeners ---
    paletteModeSelector.addEventListener('change', (e) => {
        const mode = e.target.value;
        smartPaletteControls.style.display = (mode === 'smart' || mode === 'smart-lines') ? 'block' : 'none';
        customPaletteControls.style.display = (mode === 'custom') ? 'block' : 'none';

        if (mode === 'smart-lines') {
            foregroundSeparationControl.style.display = 'none';
        } else {
            foregroundSeparationControl.style.display = 'block';
        }
    });

    paletteColorsSlider.addEventListener('input', () => {
        paletteColorsValue.value = paletteColorsSlider.value;
    });
    paletteColorsValue.addEventListener('change', (e) => {
        let value = parseInt(e.target.value, 10);
        const min = parseInt(paletteColorsSlider.min, 10);
        const max = parseInt(paletteColorsSlider.max, 10);
        if (isNaN(value)) value = paletteColorsSlider.value;
        if (value < min) value = min;
        if (value > max) value = max;
        e.target.value = value;
        paletteColorsSlider.value = value;
    });
    paletteColorsValue.addEventListener('focus', e => e.target.select());
    
    foregroundThresholdSlider.addEventListener('input', () => {
        foregroundThresholdValue.value = foregroundThresholdSlider.value;
    });
    foregroundThresholdValue.addEventListener('change', (e) => {
        let value = parseInt(e.target.value, 10);
        const min = parseInt(foregroundThresholdSlider.min, 10);
        const max = parseInt(foregroundThresholdSlider.max, 10);
        if (isNaN(value)) value = foregroundThresholdSlider.value;
        if (value < min) value = min;
        if (value > max) value = max;
        e.target.value = value;
        foregroundThresholdSlider.value = value;
    });
    foregroundThresholdValue.addEventListener('focus', e => e.target.select());

    analyzePaletteBtn.addEventListener('click', analyzeSmartPalette);
    analyzeBinnedBtn.addEventListener('click', analyzeBinnedBackgroundColor);
    analyzeAverageBtn.addEventListener('click', analyzeAverageBackgroundColor);

    addCustomColorBtn.addEventListener('click', () => {
        addCustomColorPicker();
    });

    // --- Core Functions ---
    function getAllPins() {
        const allPins = [];
        let pinIdCounter = 0;
        
        const numPins = parseInt(sliders.pins.value, 10);
        const pinDiameter = parseFloat(sliders.pinDiameter.value);
        const w = previewCanvas.width;
        const h = previewCanvas.height;
        const radius = Math.min(w, h) / 2;
        const center = { x: w / 2, y: h / 2 };
        const artDiameterMm = 400;
        const pxPerMm = w / artDiameterMm;
        const pinRadiusPx = (pinDiameter / 2) * pxPerMm;

        // Add Outer Pins
        for (let i = 0; i < numPins; i++) {
            const angle = -Math.PI / 2 + (i / numPins) * 2 * Math.PI;
            const pinCenterX = center.x + radius * Math.cos(angle);
            const pinCenterY = center.y + radius * Math.sin(angle);
            
            // Tangent vector is 90 degrees to the radius vector
            const tangentAngle = angle + Math.PI / 2;

            const pAx = pinCenterX - pinRadiusPx * Math.cos(tangentAngle);
            const pAy = pinCenterY - pinRadiusPx * Math.sin(tangentAngle);
            const pBx = pinCenterX + pinRadiusPx * Math.cos(tangentAngle);
            const pBy = pinCenterY + pinRadiusPx * Math.sin(tangentAngle);

            // Push A side (clockwise)
            allPins.push({
                id: pinIdCounter++,
                type: 'O',
                num: i + 1,
                side: 'A',
                x: pAx,
                y: pAy
            });
            // Push B side (anti-clockwise)
            allPins.push({
                id: pinIdCounter++,
                type: 'O',
                num: i + 1,
                side: 'B',
                x: pBx,
                y: pBy
            });
        }

        // Add Central Pin
        if (centralPinEnabledCheckbox.checked) {
            allPins.push({
                id: pinIdCounter++,
                type: 'C', // Central
                num: 1,
                x: center.x,
                y: center.y
            });
        }

        // Add Middle Pins
        if (areMiddlePinsEnabled) {
            const numMiddlePins = parseInt(middlePinsSlider.value, 10);
            const middleRadius = radius / 2;
            for (let i = 0; i < numMiddlePins; i++) {
                const angle = -Math.PI / 2 + (i / numMiddlePins) * 2 * Math.PI;
                allPins.push({
                    id: pinIdCounter++,
                    type: 'M', // Middle
                    num: i + 1,
                    x: center.x + middleRadius * Math.cos(angle),
                    y: center.y + middleRadius * Math.sin(angle)
                });
            }
        }
        return allPins;
    }

    function updatePreviewBackground() {
        const w = previewCanvas.width;
        const h = previewCanvas.height;
        previewCtx.fillStyle = currentBackgroundColor;
        previewCtx.fillRect(0, 0, w, h);
    }

    function updatePreviewBackgroundAndPins() {
        updatePreviewBackground();
        const numPins = parseInt(sliders.pins.value, 10);
        const w = previewCanvas.width;
        const h = previewCanvas.height;
        const radius = Math.min(w, h) / 2;
        const center = { x: w / 2, y: h / 2 };
        const pinDiameter = parseFloat(sliders.pinDiameter.value);
        const artDiameterMm = 400;
        const pxPerMm = w / artDiameterMm;
        const pinRadiusPx = (pinDiameter / 2) * pxPerMm;

        previewCtx.fillStyle = 'white'; // Pin color

        // Draw Outer Pins
        for (let i = 0; i < numPins; i++) {
            const angle = -Math.PI / 2 + (i / numPins) * 2 * Math.PI;
            const pinCenterX = center.x + radius * Math.cos(angle);
            const pinCenterY = center.y + radius * Math.sin(angle);
            
            previewCtx.beginPath();
            previewCtx.arc(pinCenterX, pinCenterY, pinRadiusPx, 0, 2 * Math.PI);
            previewCtx.fill();
        }

        // Draw Central Pin
        if (isCentralPinEnabled) {
            previewCtx.beginPath();
            previewCtx.arc(center.x, center.y, pinRadiusPx, 0, 2 * Math.PI);
            previewCtx.fill();
        }

        // Draw Middle Pins
        if (areMiddlePinsEnabled) {
            const numMiddlePins = parseInt(middlePinsSlider.value, 10);
            const middleRadius = radius / 2;
            for (let i = 0; i < numMiddlePins; i++) {
                const angle = -Math.PI / 2 + (i / numMiddlePins) * 2 * Math.PI;
                const pinCenterX = center.x + middleRadius * Math.cos(angle);
                const pinCenterY = center.y + middleRadius * Math.sin(angle);
                
                previewCtx.beginPath();
                previewCtx.arc(pinCenterX, pinCenterY, pinRadiusPx, 0, 2 * Math.PI);
                previewCtx.fill();
            }
        }
    }

    function processImageAndRedraw() {
        if (!sourceImage || !processedImageCanvas) return;
        
        const pCtx = processedImageCanvas.getContext('2d');
        // Use a neutral background color that won't interfere with masking.
        pCtx.fillStyle = '#f9f9f9'; 
        pCtx.fillRect(0, 0, pCtx.canvas.width, pCtx.canvas.height);
        
        // Draw the transformed source image (pan/zoom) onto the offscreen canvas
        const { scale, pos } = imageTransform;
        pCtx.save();
        pCtx.translate(pos.x * scale, pos.y * scale);
        pCtx.scale(scale, scale);
        pCtx.drawImage(sourceImage, 0, 0);
        pCtx.restore();
        
        const imageData = pCtx.getImageData(0, 0, pCtx.canvas.width, pCtx.canvas.height);
        const data = imageData.data;

        const brightness = parseInt(sliders.brightness.value, 10) - 100;
        const contrast = parseInt(sliders.contrast.value, 10) - 100;
        const saturation = parseInt(sliders.saturation.value, 10) / 100;
        const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));

        for (let i = 0; i < data.length; i += 4) {
            // Apply Brightness
            let r = data[i] + brightness;
            let g = data[i + 1] + brightness;
            let b = data[i + 2] + brightness;

            // Apply Contrast
            r = factor * (r - 128) + 128;
            g = factor * (g - 128) + 128;
            b = factor * (b - 128) + 128;

            // Apply Saturation
            if (saturation !== 1) {
                const luma = 0.299 * r + 0.587 * g + 0.114 * b;
                r = luma + saturation * (r - luma);
                g = luma + saturation * (g - luma);
                b = luma + saturation * (b - luma);
            }
            
            // Clamp values
            data[i] = Math.max(0, Math.min(255, r));
            data[i + 1] = Math.max(0, Math.min(255, g));
            data[i + 2] = Math.max(0, Math.min(255, b));
        }

        pCtx.putImageData(imageData, 0, 0);
        updateSourceCanvas();
    }

    function updateSourceCanvas() {
        if (!sourceImage || !processedImageCanvas) {
            initializeCanvases();
            return;
        };

        const w = sourceCanvas.width;
        const h = sourceCanvas.height;

        // Clear and draw the processed (brightness/contrast) image
        sourceCtx.save();
        sourceCtx.fillStyle = '#f9f9f9';
        sourceCtx.fillRect(0, 0, w, h);
        sourceCtx.drawImage(processedImageCanvas, 0, 0);

        // Apply circular mask
        sourceCtx.globalCompositeOperation = 'destination-in';
        sourceCtx.beginPath();
        sourceCtx.arc(w / 2, h / 2, Math.min(w, h) / 2, 0, 2 * Math.PI);
        sourceCtx.fill();
        sourceCtx.restore();
    }
    
    function toggleControls(disabled) {
        Object.values(sliders).forEach(slider => slider.disabled = disabled);
        generateBtn.disabled = disabled;
        imageLoader.disabled = disabled; 
        downloadResultsBtn.disabled = disabled;
        analyzePaletteBtn.disabled = disabled;
        analyzeBinnedBtn.disabled = disabled;
        analyzeAverageBtn.disabled = disabled;
        centralPinEnabledCheckbox.disabled = disabled;
        middlePinsEnabledCheckbox.disabled = disabled;
        middlePinsSlider.disabled = disabled;
        middlePinsValue.disabled = disabled;
        sliders.monoLines.disabled = disabled;
        sliderValues.monoLines.disabled = disabled;
        colorForcingEnabledCheckbox.disabled = disabled;
        colorForcingPercentageSlider.disabled = disabled;
        colorForcingPercentageValue.disabled = disabled;
        dominanceThresholdSlider.disabled = disabled;
        dominanceThresholdValue.disabled = disabled;
    }

    async function generateArt() {
        if (!sourceImage) {
            alert('Please upload an image first.');
            return;
        }
        if (isGenerating) return;
        
        console.time('Total Generation');
        
        // --- Generation Setup ---
        isGenerating = true;
        isPaused = false;
        stopGeneration = false;
        toggleControls(true);
        generateBtn.style.display = 'none';
        generationProgressContainer.style.display = 'block';
        statsContainer.style.display = 'flex';
        pauseResumeBtn.textContent = 'Pause';
        pinSequence = [];
        similarityHistory = [];
        connectionPoints = [];
        totalStringLengthMm = 0;

        // 1. Setup
        const numPins = parseInt(sliders.pins.value, 10);
        const pinDiameter = parseFloat(sliders.pinDiameter.value);
        const numLines = parseInt(sliders.lines.value, 10);
        const lineOpacity = parseInt(sliders.opacity.value, 10) / 100;
        const minPinDistance = parseInt(sliders.minPinDistance.value, 10);
        const monoLines = parseInt(sliders.monoLines.value, 10);
        
        const w = previewCanvas.width;
        const h = previewCanvas.height;
        const radius = Math.min(w, h) / 2;
        const center = { x: w / 2, y: h / 2 };
        const artDiameterMm = 400;
        const pxPerMm = w / artDiameterMm;
        const pinRadiusPx = (pinDiameter / 2) * pxPerMm;
        const radiusSq = radius * radius;
        
        // Central Pin params
        const centralPinEnabled = centralPinEnabledCheckbox.checked;

        // Progress UI
        generationProgress.max = numLines;
        generationProgress.value = 0;
        progressText.textContent = `0 / ${numLines}`;

        // Clear preview canvas and draw pins
        updatePreviewBackgroundAndPins();

        // --- NEW: Unified Pin Setup ---
        const allPins = getAllPins();
        
        if (allPins.length < 2) {
            alert("Not enough pins to generate artwork. Enable at least two pins.");
            isGenerating = false;
            toggleControls(false);
            generateBtn.style.display = 'block';
            generationProgressContainer.style.display = 'none';
            return;
        }


        // 3. Get target image data & initialize buffers
        updateSourceCanvas(); // Ensure source is processed and masked
        const targetData = sourceCtx.getImageData(0, 0, w, h).data;
        const currentData = previewCtx.getImageData(0, 0, w, h).data; // Starts with background color

        // Calculate initial similarity
        const initialSimilarity = calculateSimilarity(targetData, currentData, w, h);
        similarityHistory.push(initialSimilarity);
        similarityScore.textContent = `${initialSimilarity.toFixed(2)}%`;
        drawSimilarityGraph();

        // 4. Thread setup based on palette mode
        let paletteToUse = [];
        const selectedPalette = paletteModeSelector.value;

        if (selectedPalette === 'custom') {
            const colorPickers = customPalettePickerContainer.querySelectorAll('input[type="color"]');
            colorPickers.forEach((picker, i) => {
                const hex = picker.value;
                const r = parseInt(hex.substring(1, 3), 16);
                const g = parseInt(hex.substring(3, 5), 16);
                const b = parseInt(hex.substring(5, 7), 16);
                paletteToUse.push({ name: `C${i + 1}`, color: [r, g, b] });
            });
        } else if ((selectedPalette === 'smart' || selectedPalette === 'smart-lines') && activePalette.length > 0) {
            paletteToUse = activePalette.map((rgb, i) => ({ name: `C${i+1}`, color: rgb }));
        } else if (selectedPalette === 'vibrant') {
            paletteToUse = vibrantThreads;
        } else if (selectedPalette === 'extended-classic') {
            paletteToUse = extendedClassicThreads;
        } else if (selectedPalette === 'low-saturation') {
            paletteToUse = lowSaturationThreads;
        } else if (selectedPalette === 'super-extended') {
            paletteToUse = superExtendedThreads;
        } else if (selectedPalette === 'greyscale') {
            paletteToUse = greyscaleThreads;
        } else if (selectedPalette === 'black-white') {
            paletteToUse = blackAndWhiteThreads;
        } else if (selectedPalette === 'black') {
            paletteToUse = blackThreads;
        } else if (selectedPalette === 'white') {
            paletteToUse = whiteThreads;
        } else { // 'classic' or fallback
            paletteToUse = classicThreads;
        }

        if (paletteToUse.length === 0) {
            alert("No color palette available. Please select a valid palette or analyze image colors for 'Smart' mode.");
            isGenerating = false;
            toggleControls(false);
            generateBtn.style.display = 'block';
            generationProgressContainer.style.display = 'none';
            return;
        }

        const threads = paletteToUse.map(p => ({
            ...p,
            posIdx: Math.floor(Math.random() * allPins.length)
        }));
        
        const monoThreads = threads.filter(t => t.color[0] === t.color[1] && t.color[1] === t.color[2]);

        // 5. Main Loop
        let lineCounter = 0;

        // --- Phase 1: Monochromatic Lines ---
        console.log(`Starting Phase 1: Monochromatic Lines (${monoLines} lines)`);
        for (let i = 0; i < monoLines && lineCounter < numLines; i++) {
            if (stopGeneration) break;
            while (isPaused) { await new Promise(resolve => setTimeout(resolve, 100)); if (stopGeneration) break; }
            if (stopGeneration) break;

            await executeBestMove(monoThreads.length > 0 ? monoThreads : threads, allPins, { targetData, currentData, w, h, center, radiusSq, lineOpacity, minPinDistance, numPins });
            lineCounter++;
            await updateProgressUI(lineCounter, numLines);
        }
        
        // --- Phase 2: Color Forcing ---
        if (isColorForcingEnabled && !stopGeneration) {
            const forcingPercentage = parseInt(colorForcingPercentageSlider.value, 10) / 100;
            const forcingLinesTotal = Math.floor((numLines - monoLines) * forcingPercentage);
            const dominanceThreshold = parseInt(dominanceThresholdSlider.value, 10);
            console.log(`Starting Phase 2: Color Forcing (${forcingLinesTotal} lines)`);

            const nonMonoThreads = threads.filter(t => !monoThreads.includes(t));
            if (nonMonoThreads.length > 0) {
                progressText.textContent = 'Analyzing...';
                await new Promise(resolve => requestAnimationFrame(resolve)); // Allow UI to update
                const colorDistribution = await calculateColorDistribution(targetData, nonMonoThreads.map(t => t.color), w, h, center, radiusSq, dominanceThreshold);
                
                for (const thread of nonMonoThreads) {
                    const threadColorKey = thread.color.join(',');
                    const numLinesForThread = Math.round(forcingLinesTotal * colorDistribution[threadColorKey]);

                    for (let i = 0; i < numLinesForThread && lineCounter < numLines; i++) {
                        if (stopGeneration) break;
                        while (isPaused) { await new Promise(resolve => setTimeout(resolve, 100)); if (stopGeneration) break; }
                        if (stopGeneration) break;
                        
                        await executeBestMove([thread], allPins, { targetData, currentData, w, h, center, radiusSq, lineOpacity, minPinDistance, numPins });
                        lineCounter++;
                        await updateProgressUI(lineCounter, numLines);
                    }
                    if (stopGeneration) break;
                }
            }
        }
        
        // --- Phase 3: Open Competition ---
        console.log(`Starting Phase 3: Open Competition (${numLines - lineCounter} lines)`);
        while (lineCounter < numLines && !stopGeneration) {
            if (stopGeneration) break;
            while (isPaused) { await new Promise(resolve => setTimeout(resolve, 100)); if (stopGeneration) break; }
            if (stopGeneration) break;

            await executeBestMove(threads, allPins, { targetData, currentData, w, h, center, radiusSq, lineOpacity, minPinDistance, numPins });
            lineCounter++;
            await updateProgressUI(lineCounter, numLines);
        }
        
        // --- Cleanup ---
        hasGenerated = true;
        isGenerating = false;
        toggleControls(false);
        generateBtn.style.display = 'block';
        generationProgressContainer.style.display = 'none';
        console.timeEnd('Total Generation');
    }

    async function executeBestMove(threadsForStep, allPins, params) {
        let bestMove = { score: -Infinity };
        const { targetData, currentData, w, h, center, radiusSq, lineOpacity, minPinDistance, numPins } = params;

        // Find the best move among all threads
        for (const thread of threadsForStep) {
            const currentPin = allPins[thread.posIdx];
            
            for (let nextIdx = 0; nextIdx < allPins.length; nextIdx++) {
                const nextPin = allPins[nextIdx];

                // Prevent connecting to the same physical pin.
                if (currentPin.type === nextPin.type && currentPin.num === nextPin.num) {
                    continue; 
                }
                
                // Apply min distance rule only for outer-to-outer connections
                if (minPinDistance > 0 && currentPin.type === 'O' && nextPin.type === 'O') {
                    const diff = Math.abs(currentPin.num - nextPin.num);
                    const distance = Math.min(diff, numPins - diff);
                    if (distance < minPinDistance) {
                        continue;
                    }
                }

                // --- Evaluate DIRECT path ---
                const pathPixels = getLinePixels(currentPin, nextPin, w, h);
                const score = calculateScoreForPath(pathPixels, targetData, currentData, thread.color, lineOpacity, center, radiusSq);

                if (score > bestMove.score) {
                    bestMove = {
                        score: score,
                        thread,
                        startPin: currentPin,
                        endPin: nextPin,
                        endPinIdx: nextIdx,
                        pixels: pathPixels
                    };
                }
            }
        }
        
        if (bestMove.score === -Infinity) return; // No improvement found
        
        const { thread, startPin, endPin, endPinIdx, pixels } = bestMove;
        
        // Draw the winning line on the visible canvas
        previewCtx.beginPath();
        previewCtx.moveTo(startPin.x, startPin.y);
        previewCtx.lineTo(endPin.x, endPin.y);

        previewCtx.strokeStyle = `rgba(${thread.color.join(',')}, ${lineOpacity})`;
        previewCtx.lineWidth = 1;
        previewCtx.stroke();
        
        // Update the underlying currentData buffer for the next iteration's calculations
        const [sR, sG, sB] = thread.color;
        const a = lineOpacity;
        for (const p of pixels) {
             const dx = p.x - center.x;
             const dy = p.y - center.y;
             if ((dx * dx + dy * dy) > radiusSq) continue;

            const idx = (p.y * w + p.x) * 4;
            currentData[idx] = sR * a + currentData[idx] * (1 - a);
            currentData[idx+1] = sG * a + currentData[idx+1] * (1 - a);
            currentData[idx+2] = sB * a + currentData[idx+2] * (1 - a);
        }
        
        // Add length to total for stats
        const dx = endPin.x - startPin.x;
        const dy = endPin.y - startPin.y;
        const artDiameterMm = 400;
        const pxPerMm = w / artDiameterMm;
        totalStringLengthMm += Math.sqrt(dx*dx + dy*dy) / pxPerMm;
        
        // Update similarity score and graph
        const currentSimilarity = calculateSimilarity(targetData, currentData, w, h);
        similarityHistory.push(currentSimilarity);
        similarityScore.textContent = `${currentSimilarity.toFixed(2)}%`;
        drawSimilarityGraph();

        // Update sequence log
        pinSequence.push({
            thread: thread.name,
            from: `${startPin.type}${startPin.num}${startPin.side || ''}`,
            to: `${endPin.type}${endPin.num}${endPin.side || ''}`
        });
        
        // Update the winning thread's position for the next iteration
        let nextPosIdx = endPinIdx;
        // If we landed on an outer pin, the next start point is the other side of that same pin.
        if (endPin.type === 'O') {
            // Sibling is at +/- 1 because we add A and B points in pairs
            nextPosIdx = (endPinIdx % 2 === 0) ? endPinIdx + 1 : endPinIdx - 1;
        }
        thread.posIdx = nextPosIdx;
    }

    async function updateProgressUI(current, total) {
        generationProgress.value = current;
        progressText.textContent = `${current} / ${total}`;
        // Yield to browser to prevent freezing
        await new Promise(resolve => requestAnimationFrame(resolve));
    }


    async function calculateColorDistribution(imageData, paletteColors, width, height, center, radiusSq, dominanceThreshold = 0) {
        const distribution = {};
        let totalClosestPixels = 0;
        paletteColors.forEach(c => distribution[c.join(',')] = 0);

        const pixelsPerChunk = 25000; // Process in chunks to avoid freezing the browser
        let processedInChunk = 0;

        // Introduce sampling to drastically reduce the number of pixels to check
        const step = Math.max(1, Math.floor(width / 250));

        for (let y = 0; y < height; y += step) {
            for (let x = 0; x < width; x += step) {
                const dx = x - center.x;
                const dy = y - center.y;
                if (dx * dx + dy * dy <= radiusSq) {
                    const idx = (y * width + x) * 4;
                    const pixelColor = [imageData[idx], imageData[idx+1], imageData[idx+2]];

                    // ---- Dominance threshold filter ----
                    if (dominanceThreshold > 0) {
                        const [r, g, b] = pixelColor;
                        const maxVal = Math.max(r, g, b);
                        let secondMax;
                        if (maxVal === r) {
                            secondMax = Math.max(g, b);
                        } else if (maxVal === g) {
                            secondMax = Math.max(r, b);
                        } else {
                            secondMax = Math.max(r, g);
                        }
                        if ((maxVal - secondMax) < dominanceThreshold) {
                            continue; // Pixel is not sufficiently dominated by a single channel
                        }
                    }

                    let minDist = Infinity;
                    let closestPaletteColor = null;
                    for (const paletteColor of paletteColors) {
                        const dist = colorDistance(pixelColor, paletteColor);
                        if (dist < minDist) {
                            minDist = dist;
                            closestPaletteColor = paletteColor;
                        }
                    }

                    if (closestPaletteColor) {
                        distribution[closestPaletteColor.join(',')]++;
                        totalClosestPixels++;
                    }

                    processedInChunk++;
                    if (processedInChunk >= pixelsPerChunk) {
                        await new Promise(resolve => setTimeout(resolve, 0)); // Yield to main thread
                        processedInChunk = 0;
                    }
                }
            }
        }

        // Normalize the distribution; if none qualified fall back to equal splits
        if (totalClosestPixels > 0) {
            for (const colorKey in distribution) {
                distribution[colorKey] /= totalClosestPixels;
            }
        } else {
            const equal = 1 / paletteColors.length;
            for (const colorKey in distribution) {
                distribution[colorKey] = equal;
            }
        }
        
        return distribution;
    }


    function calculateSimilarity(target, current, width, height) {
        const radius = width / 2;
        const radiusSq = radius * radius;
        const center = { x: radius, y: radius };
        
        let totalSimilarity = 0;
        let pixelCount = 0;
        const maxPixelDiff = Math.sqrt(3 * (255 ** 2)); // Max distance between black (0,0,0) and white (255,255,255)

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const dx = x - center.x;
                const dy = y - center.y;
                if (dx * dx + dy * dy <= radiusSq) {
                    const idx = (y * width + x) * 4;
                    const tR = target[idx], tG = target[idx + 1], tB = target[idx + 2];
                    const cR = current[idx], cG = current[idx + 1], cB = current[idx + 2];
                    
                    // Calculate Euclidean distance for colors. This captures color difference, not just brightness.
                    const diff = Math.sqrt((tR - cR)**2 + (tG - cG)**2 + (tB - cB)**2);
                    
                    // Calculate this pixel's similarity score (0 to 1)
                    const pixelSimilarity = 1 - (diff / maxPixelDiff);
                    
                    totalSimilarity += pixelSimilarity;
                    pixelCount++;
                }
            }
        }
        
        if (pixelCount === 0) return 100;

        // The final score is the average of all individual pixel similarities
        const averageSimilarity = totalSimilarity / pixelCount;
        return Math.max(0, averageSimilarity * 100);
    }

    function drawSimilarityGraph() {
        const w = similarityGraphCanvas.width;
        const h = similarityGraphCanvas.height;
        similarityGraphCtx.fillStyle = '#f9f9f9';
        similarityGraphCtx.fillRect(0, 0, w, h);

        if (similarityHistory.length < 2) return;
        
        const numLines = parseInt(sliders.lines.value, 10);
        const startSimilarity = similarityHistory[0];
        const maxSimilarity = Math.max(...similarityHistory);
        const yAxisTop = Math.min(100, Math.ceil(maxSimilarity / 5) * 5 + 5); // Go up to the next 5% interval, or 100
        const yRange = yAxisTop - startSimilarity;

        similarityGraphCtx.strokeStyle = '#007bff';
        similarityGraphCtx.lineWidth = 2;
        similarityGraphCtx.beginPath();
        
        for (let i = 0; i < similarityHistory.length; i++) {
            const x = (i / (numLines - 1)) * w;
            const y = (yRange > 0.1) ? h - ((similarityHistory[i] - startSimilarity) / yRange) * h : h;
            if (i === 0) {
                similarityGraphCtx.moveTo(x, y);
            } else {
                similarityGraphCtx.lineTo(x, y);
            }
        }
        similarityGraphCtx.stroke();

        // Draw Axes and Labels
        similarityGraphCtx.fillStyle = '#666';
        similarityGraphCtx.font = '12px Arial';
        similarityGraphCtx.textAlign = 'left';
        similarityGraphCtx.fillText(`${Math.round(startSimilarity)}%`, 5, h - 5);
        similarityGraphCtx.textAlign = 'right';
        similarityGraphCtx.fillText(`${Math.round(yAxisTop)}%`, w - 5, 15);
    }
    
    function calculateScoreForPath(pixels, targetData, currentData, threadColor, lineOpacity, center, radiusSq) {
        let currentError = 0;
        let nextError = 0;
        let pixelCount = 0;

        const w = Math.sqrt(targetData.length / 4);
        const [sR, sG, sB] = threadColor;
        const a = lineOpacity;

        for (const p of pixels) {
            const dx = p.x - center.x;
            const dy = p.y - center.y;
            if ((dx * dx + dy * dy) > radiusSq) continue;

            const idx = (p.y * w + p.x) * 4;
            
            const tR = targetData[idx];
            const tG = targetData[idx + 1];
            const tB = targetData[idx + 2];

            const cR = currentData[idx];
            const cG = currentData[idx + 1];
            const cB = currentData[idx + 2];
            
            currentError += (tR - cR)**2 + (tG - cG)**2 + (tB - cB)**2;
            
            const nR = sR * a + cR * (1 - a);
            const nG = sG * a + cG * (1 - a);
            const nB = sB * a + cB * (1 - a);
            
            nextError += (tR - nR)**2 + (tG - nG)**2 + (tB - nB)**2;
            pixelCount++;
        }

        return (pixelCount > 0) ? (currentError - nextError) / pixelCount : -Infinity;
    }


    // --- Color Analysis Functions ---

    async function analyzeAverageBackgroundColor() {
        if (!sourceImage) {
            alert('Please upload an image first.');
            return;
        }

        const btn = analyzeAverageBtn;
        const originalText = btn.textContent;
        toggleControls(true);
        btn.textContent = 'Analyzing...';
        await new Promise(resolve => setTimeout(resolve, 10));

        try {
            console.time('Average Background Analysis');
            const imagePixels = getCircularImageData(sourceCanvas);
            if (imagePixels.length === 0) {
                alert("Could not find image data. Please make sure an image is loaded.");
                return;
            }

            const backgroundRgb = findAverageColor(imagePixels);
            const backgroundHex = `#${backgroundRgb.map(c => c.toString(16).padStart(2, '0')).join('')}`;
            
            if (hasGenerated) {
                hasGenerated = false;
                pinSequence = [];
            }
            currentBackgroundColor = backgroundHex;
            backgroundColorPicker.value = backgroundHex;
            updatePreviewBackgroundAndPins();

            console.timeEnd('Average Background Analysis');
        } catch (error) {
            console.error("An error occurred during average color analysis:", error);
            alert("An error occurred during average color analysis. Check the console for details.");
        } finally {
            toggleControls(false);
            btn.textContent = originalText;
        }
    }


    async function analyzeBinnedBackgroundColor() {
        if (!sourceImage) {
            alert('Please upload an image first.');
            return;
        }

        const btn = analyzeBinnedBtn;
        const originalText = btn.textContent;
        toggleControls(true);
        btn.textContent = 'Analyzing...';
        await new Promise(resolve => setTimeout(resolve, 10));

        try {
            console.time('Binned Background Analysis');
            const imagePixels = getCircularImageData(sourceCanvas);
            if (imagePixels.length === 0) {
                alert("Could not find image data. Please make sure an image is loaded.");
                return;
            }

            const backgroundRgb = findMostCommonColor(imagePixels, binnedBackgroundPrecision);
            const backgroundHex = `#${backgroundRgb.map(c => c.toString(16).padStart(2, '0')).join('')}`;
            
            if (hasGenerated) {
                hasGenerated = false;
                pinSequence = [];
            }
            currentBackgroundColor = backgroundHex;
            backgroundColorPicker.value = backgroundHex;
            updatePreviewBackgroundAndPins();

            binnedBackgroundPrecision = (binnedBackgroundPrecision % 10) + 1;
            updateBinnedPrecisionText();

            console.timeEnd('Binned Background Analysis');
        } catch (error) {
            console.error("An error occurred during binned background color analysis:", error);
            alert("An error occurred during binned background color analysis. Check the console for details.");
        } finally {
            toggleControls(false);
            btn.textContent = originalText;
        }
    }


    function analyzeSmartPalette() {
        if (!sourceImage) {
            alert('Please upload an image first.');
            return;
        }
        const mode = paletteModeSelector.value;
        if (mode === 'smart') {
            analyzeSmartPaletteFromPixels();
        } else if (mode === 'smart-lines') {
            analyzeSmartPaletteFromLines();
        }
    }

    function getLineAverageColor(p1, p2, canvas) {
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const linePixels = getLinePixels(p1, p2, canvas.width, canvas.height);
        
        if (linePixels.length === 0) return null;

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        let r = 0, g = 0, b = 0, count = 0;
        
        for (const pixel of linePixels) {
            const idx = (pixel.y * canvas.width + pixel.x) * 4;
            // Only consider opaque pixels
            if (imageData[idx + 3] > 128) {
                r += imageData[idx];
                g += imageData[idx + 1];
                b += imageData[idx + 2];
                count++;
            }
        }

        if (count === 0) return null;

        return [r / count, g / count, b / count];
    }

    async function analyzeSmartPaletteFromLines() {
        const btn = document.getElementById('analyzePaletteBtn');
        const originalText = btn.textContent;
        toggleControls(true);
        btn.textContent = 'Analyzing Lines...';
        await new Promise(resolve => setTimeout(resolve, 10)); // Allow UI to update

        try {
            console.time('Line-based Palette Analysis');
            updateSourceCanvas(); // Ensure the source canvas is up-to-date with transforms

            const allPins = getAllPins();
            if (allPins.length < 2) {
                alert("Not enough pins defined to analyze lines. Please increase pin count.");
                return;
            }

            const totalPossibleLines = (allPins.length * (allPins.length - 1)) / 2;
            const numSamples = Math.min(10000, totalPossibleLines);
            
            console.log(`Analyzing ${numSamples} of ${totalPossibleLines} possible lines.`);

            const lineAverageColors = [];
            
            if (numSamples === totalPossibleLines) {
                // Analyze all lines
                for (let i = 0; i < allPins.length; i++) {
                    for (let j = i + 1; j < allPins.length; j++) {
                        const avgColor = getLineAverageColor(allPins[i], allPins[j], sourceCanvas);
                        if (avgColor) lineAverageColors.push(avgColor);
                    }
                }
            } else {
                // Analyze a random sample
                const sampledPairs = new Set();
                while (lineAverageColors.length < numSamples && sampledPairs.size < totalPossibleLines) {
                    let i = Math.floor(Math.random() * allPins.length);
                    let j = Math.floor(Math.random() * allPins.length);
                    if (i === j) continue;
                    
                    // Ensure pair is unique (e.g. 1-5 is same as 5-1)
                    const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                    if (sampledPairs.has(key)) continue;
                    
                    sampledPairs.add(key);
                    const avgColor = getLineAverageColor(allPins[i], allPins[j], sourceCanvas);
                    if (avgColor) lineAverageColors.push(avgColor);
                }
            }
            
            if (lineAverageColors.length === 0) {
                alert("Could not extract any line color data from the image.");
                return;
            }

            // --- Run k-means on the line average colors ---
            const numPaletteColors = parseInt(paletteColorsSlider.value, 10);
            
            if (lineAverageColors.length < numPaletteColors) {
                alert(`Not enough distinct line colors found to generate a ${numPaletteColors}-color palette.`);
                activePalette = lineAverageColors.map(p => p.map(Math.round));
            } else {
                const numCandidateColors = Math.max(numPaletteColors * 3, 15);
                const kMeansInput = lineAverageColors;
                const candidateClusters = kMeans(kMeansInput, Math.min(numCandidateColors, kMeansInput.length), 'kmeans++');
                const candidateColors = candidateClusters.map(c => c.centroid);

                const finalPalette = selectDiverseColors(candidateColors, numPaletteColors);
                activePalette = finalPalette.map(c => c.map(Math.round));
            }

            // Add Black and White to the generated palette if they don't already exist
            if (!activePalette.some(c => c[0] === 255 && c[1] === 255 && c[2] === 255)) {
                activePalette.push([255, 255, 255]);
            }
            if (!activePalette.some(c => c[0] === 0 && c[1] === 0 && c[2] === 0)) {
                activePalette.push([0, 0, 0]);
            }

            updatePaletteDisplay(activePalette);
            console.timeEnd('Line-based Palette Analysis');

        } catch (error) {
            console.error("An error occurred during line-based color palette analysis:", error);
            alert("An error occurred during line-based color palette analysis. Check the console for details.");
        } finally {
            toggleControls(false);
            btn.textContent = originalText;
        }
    }


    async function analyzeSmartPaletteFromPixels() {
        const btn = document.getElementById('analyzePaletteBtn');
        const originalText = btn.textContent;
        toggleControls(true);
        btn.textContent = 'Analyzing Pixels...';
        await new Promise(resolve => setTimeout(resolve, 10)); // Allow UI to update

        try {
            console.time('Palette Analysis');
            const imagePixels = getCircularImageData(sourceCanvas);
            if (imagePixels.length === 0) {
                alert("Could not find image data. Please make sure an image is loaded.");
                return;
            }

            // --- Get current background color (manual or analyzed) ---
            const backgroundRgb = currentBackgroundColor.match(/\w\w/g).map(c => parseInt(c, 16));

            // --- Filter out background-like pixels ---
            const similarityThreshold = parseInt(foregroundThresholdSlider.value, 10);
            const foregroundPixels = imagePixels.filter(p => colorDistance(p, backgroundRgb) > similarityThreshold);

            // --- Run k-means on the remaining "foreground" pixels ---
            const numPaletteColors = parseInt(paletteColorsSlider.value, 10);
            
            if (foregroundPixels.length < numPaletteColors) {
                alert(`Not enough distinct foreground colors found to generate a ${numPaletteColors}-color palette. Try adjusting the Foreground Separation threshold.`);
                activePalette = foregroundPixels.map(p => p.map(Math.round));
            } else {
                const numCandidateColors = Math.max(numPaletteColors * 3, 15);
                const candidateClusters = kMeans(foregroundPixels, Math.min(numCandidateColors, foregroundPixels.length), 'kmeans++');
                const candidateColors = candidateClusters.map(c => c.centroid);

                const finalPalette = selectDiverseColors(candidateColors, numPaletteColors);
                activePalette = finalPalette.map(c => c.map(Math.round));
            }

            // Add Black and White to the generated palette if they don't already exist
            if (!activePalette.some(c => c[0] === 255 && c[1] === 255 && c[2] === 255)) {
                activePalette.push([255, 255, 255]);
            }
            if (!activePalette.some(c => c[0] === 0 && c[1] === 0 && c[2] === 0)) {
                activePalette.push([0, 0, 0]);
            }

            updatePaletteDisplay(activePalette);
            console.timeEnd('Palette Analysis');

        } catch (error) {
            console.error("An error occurred during color palette analysis:", error);
            alert("An error occurred during color palette analysis. Check the console for details.");
        } finally {
            toggleControls(false);
            btn.textContent = originalText;
        }
    }

    function getCircularImageData(canvas) {
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const radius = canvas.width / 2;
        const radiusSq = radius * radius;
        const center = { x: radius, y: radius };
        
        const pixels = [];
        // For performance, we can sample a subset of pixels, e.g., every 2nd pixel in each direction
        const step = Math.max(1, Math.floor(canvas.width / 250)); // Sample more on larger canvases

        for (let y = 0; y < canvas.height; y += step) {
            for (let x = 0; x < canvas.width; x += step) {
                const dx = x - center.x;
                const dy = y - center.y;
                if (dx * dx + dy * dy <= radiusSq) {
                    const i = (y * canvas.width + x) * 4;
                    if (data[i + 3] > 128) { // Only count opaque pixels
                       pixels.push([data[i], data[i+1], data[i+2]]);
                    }
                }
            }
        }
        return pixels;
    }

    function findAverageColor(pixels) {
        if (!pixels || pixels.length === 0) return [0, 0, 0];
        const sum = pixels.reduce((acc, p) => {
            acc[0] += p[0];
            acc[1] += p[1];
            acc[2] += p[2];
            return acc;
        }, [0, 0, 0]);
        return [
            Math.round(sum[0] / pixels.length),
            Math.round(sum[1] / pixels.length),
            Math.round(sum[2] / pixels.length)
        ];
    }

    function findMostCommonColor(pixels, quant) { // quant is the bit shift value, e.g. 4
        const histogram = new Map();

        for (const pixel of pixels) {
            const r = pixel[0], g = pixel[1], b = pixel[2];
            
            // Quantize colors to group them into bins
            const r_q = r >> quant;
            const g_q = g >> quant;
            const b_q = b >> quant;
            const key = `${r_q},${g_q},${b_q}`;

            const entry = histogram.get(key);
            if (entry) {
                entry.count++;
                entry.sumR += r;
                entry.sumG += g;
                entry.sumB += b;
            } else {
                histogram.set(key, { count: 1, sumR: r, sumG: g, sumB: b });
            }
        }

        let maxCount = 0;
        let dominantBin = null;
        for (const bin of histogram.values()) {
            if (bin.count > maxCount) {
                maxCount = bin.count;
                dominantBin = bin;
            }
        }

        if (dominantBin) {
            return [
                Math.round(dominantBin.sumR / dominantBin.count),
                Math.round(dominantBin.sumG / dominantBin.count),
                Math.round(dominantBin.sumB / dominantBin.count),
            ];
        }
        return [0, 0, 0]; // Fallback
    }

    function colorDistance(c1, c2) {
        const dr = c1[0] - c2[0];
        const dg = c1[1] - c2[1];
        const db = c1[2] - c2[2];
        return Math.sqrt(dr*dr + dg*dg + db*db);
    }

    function kMeans(pixels, k, initMethod = 'random') {
        if (pixels.length < k) {
            return pixels.map(p => ({ centroid: p, size: 1 }));
        }
        
        // Initialize centroids using the specified method
        let centroids = (initMethod === 'kmeans++')
            ? initializeCentroidsKMeansPlusPlus(pixels, k)
            : initializeCentroidsRandom(pixels, k);

        const MAX_ITERATIONS = 20;
        let clusters;

        for (let iter = 0; iter < MAX_ITERATIONS; iter++) {
            clusters = Array.from({ length: k }, () => []);
            
            // Assign each pixel to the closest centroid
            for (const pixel of pixels) {
                let minDist = Infinity;
                let bestCentroidIdx = 0;
                for (let i = 0; i < k; i++) {
                    const dist = colorDistance(pixel, centroids[i]);
                    if (dist < minDist) {
                        minDist = dist;
                        bestCentroidIdx = i;
                    }
                }
                clusters[bestCentroidIdx].push(pixel);
            }

            let hasChanged = false;
            // Recalculate centroids based on the new clusters
            for (let i = 0; i < k; i++) {
                if (clusters[i].length === 0) {
                     // If a cluster becomes empty, re-seed it with a random pixel
                     // to prevent the algorithm from getting stuck.
                     if (pixels.length > 0) {
                        const idx = Math.floor(Math.random() * pixels.length);
                        centroids[i] = [...pixels[idx]];
                        hasChanged = true;
                     }
                     continue;
                }

                const sum = clusters[i].reduce((acc, p) => [acc[0] + p[0], acc[1] + p[1], acc[2] + p[2]], [0, 0, 0]);
                // Keep centroids as floats for precision during iterations
                const newCentroid = [
                    sum[0] / clusters[i].length,
                    sum[1] / clusters[i].length,
                    sum[2] / clusters[i].length
                ];

                if (colorDistance(newCentroid, centroids[i]) > 1) { // Check for meaningful change
                    hasChanged = true;
                }
                centroids[i] = newCentroid;
            }

            if (!hasChanged) break; // Converged
        }

        // Return the final centroids and the size of each cluster
        return centroids.map((centroid, i) => ({
            centroid,
            size: clusters[i] ? clusters[i].length : 0
        }));
    }

    function initializeCentroidsRandom(pixels, k) {
        const centroids = [];
        const usedIndices = new Set();
        while (centroids.length < k && usedIndices.size < pixels.length) {
            const idx = Math.floor(Math.random() * pixels.length);
            if (!usedIndices.has(idx)) {
                centroids.push([...pixels[idx]]);
                usedIndices.add(idx);
            }
        }
        return centroids;
    }

    function initializeCentroidsKMeansPlusPlus(pixels, k) {
        const centroids = [];
        // 1. Choose the first centroid randomly
        const firstIdx = Math.floor(Math.random() * pixels.length);
        centroids.push([...pixels[firstIdx]]);

        const distances = new Array(pixels.length).fill(Infinity);

        // 2. For the remaining k-1 centroids
        while (centroids.length < k) {
            let totalDistance = 0;

            // For each pixel, find the squared distance to the nearest existing centroid
            for (let i = 0; i < pixels.length; i++) {
                const pixel = pixels[i];
                let closestDistSq = distances[i];

                const distSq = colorDistance(pixel, centroids[centroids.length - 1]) ** 2;
                if (distSq < closestDistSq) {
                    distances[i] = distSq;
                }
            }

            totalDistance = distances.reduce((sum, d) => sum + d, 0);

            // Choose the next centroid with probability proportional to D(x)^2
            const randomVal = Math.random() * totalDistance;
            let cumulativeSum = 0;
            let nextCentroidIndex = -1;

            for (let i = 0; i < distances.length; i++) {
                cumulativeSum += distances[i];
                if (cumulativeSum >= randomVal) {
                    nextCentroidIndex = i;
                    break;
                }
            }
            
            if (nextCentroidIndex === -1) { // Fallback for floating point issues
                 nextCentroidIndex = pixels.length - 1;
            }

            centroids.push([...pixels[nextCentroidIndex]]);
        }

        return centroids;
    }

    function updatePaletteDisplay(palette) {
        paletteDisplay.innerHTML = '';
        if (!palette || palette.length === 0) {
            paletteDisplay.innerHTML = '<span style="font-size: 0.85rem; color: #888;">Analyze image to generate.</span>';
            return;
        }
        
        palette.forEach((colorRgb, index) => {
            const swatchContainer = document.createElement('div');
            swatchContainer.className = 'palette-swatch-container';

            const swatch = document.createElement('div');
            swatch.className = 'palette-swatch';
            swatch.style.backgroundColor = `rgb(${colorRgb.join(',')})`;
            swatch.title = `rgb(${colorRgb.join(',')})`;

            const removeBtn = document.createElement('span');
            removeBtn.className = 'remove-swatch-btn';
            removeBtn.innerHTML = '&times;'; // 'x' character
            removeBtn.title = 'Remove color';
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                activePalette.splice(index, 1);
                updatePaletteDisplay(activePalette);
            };

            swatchContainer.appendChild(swatch);
            swatchContainer.appendChild(removeBtn);
            paletteDisplay.appendChild(swatchContainer);
        });
    }

    function selectDiverseColors(colors, count) {
        if (colors.length <= count) {
            return colors.map(c => c.map(Math.round));
        }

        const palette = [];
        const remainingColors = [...colors];

        // 1. Pick the first color (can be the first in the list)
        palette.push(remainingColors.splice(0, 1)[0]);

        while (palette.length < count && remainingColors.length > 0) {
            let maxDist = -1;
            let bestCandidateIndex = -1;

            // For each remaining candidate...
            for (let i = 0; i < remainingColors.length; i++) {
                const candidate = remainingColors[i];
                let min_dist_to_palette = Infinity;

                // ...find its minimum distance to any color already in the palette
                for (const p_color of palette) {
                    const dist = colorDistance(candidate, p_color);
                    if (dist < min_dist_to_palette) {
                        min_dist_to_palette = dist;
                    }
                }

                // We want the candidate whose minimum distance to the palette is the largest
                if (min_dist_to_palette > maxDist) {
                    maxDist = min_dist_to_palette;
                    bestCandidateIndex = i;
                }
            }
            
            // Add the best candidate to the palette and remove it from remaining colors
            if (bestCandidateIndex !== -1) {
                palette.push(remainingColors.splice(bestCandidateIndex, 1)[0]);
            } else {
                // This should not happen if remainingColors is not empty, but as a fallback:
                break;
            }
        }

        return palette;
    }

    // --- Geometry & Pathing Functions ---

    // Uses Bresenham's algorithm to get pixels for a line
    function getLinePixels(p1, p2, width, height) {
        let x1 = Math.round(p1.x), y1 = Math.round(p1.y);
        let x2 = Math.round(p2.x), y2 = Math.round(p2.y);

        const pixels = [];
        const dx = Math.abs(x2 - x1);
        const dy = -Math.abs(y2 - y1);
        const sx = (x1 < x2) ? 1 : -1;
        const sy = (y1 < y2) ? 1 : -1;
        let err = dx + dy;

        while(true) {
            if (x1 >= 0 && x1 < width && y1 >= 0 && y1 < height) {
                pixels.push({ x: x1, y: y1 });
            }
            if (x1 === x2 && y1 === y2) break;
            let e2 = 2 * err;
            if (e2 >= dy) { err += dy; x1 += sx; }
            if (e2 <= dx) { err += dx; y1 += sy; }
        }
        return pixels;
    }

    function getFormattedDateTime() {
        return new Date().toISOString().replace(/[:.]/g, '-');
    }

    function buildParametersString() {
        return `Color String Art Generation Parameters
---------------------------------
Date: ${getFormattedDateTime()}
Source Image: ${imageLoader.files.length > 0 ? imageLoader.files[0].name : 'N/A'}

Artwork Parameters:
- Background Color: ${currentBackgroundColor}
- Resolution: ${currentResolution}x${currentResolution}
- Number of Pins: ${sliders.pins.value}
- Number of Lines: ${sliders.lines.value}
- Pin Diameter: ${sliders.pinDiameter.value} mm
- Line Opacity: ${sliders.opacity.value}%
- Estimated Total String Length: ${(totalStringLengthMm / 1000).toFixed(2)} m

Image Pre-processing:
- Brightness: ${sliders.brightness.value}, Contrast: ${sliders.contrast.value}
---------------------------------

Pin Sequence (Thread: From Pin -> To Pin):
`;
    }

    function buildSequenceString() {
        if (pinSequence.length === 0) return "No sequence generated.";
        return pinSequence.map(s => `${s.thread}: ${s.from} -> ${s.to}`).join('\n');
    }

    async function downloadResults() {
        if (!hasGenerated || pinSequence.length === 0) {
            alert('Please generate the artwork first before downloading.');
            return;
        }

        const zip = new JSZip();

        // 1. Add Artwork
        const artBlob = await new Promise(resolve => previewCanvas.toBlob(resolve, 'image/png'));
        zip.file('artwork.png', artBlob);

        // 2. Add Sequence File
        const paramsHeader = buildParametersString();
        const sequenceSteps = buildSequenceString();
        const fullSequenceFile = paramsHeader + sequenceSteps;
        zip.file('sequence.txt', fullSequenceFile);
        
        // 3. Add Processed Source Image
        const sourceBlob = await new Promise(resolve => sourceCanvas.toBlob(resolve, 'image/png'));
        zip.file('processed_image.png', sourceBlob);

        // 4. Generate and Trigger Download
        const zipBlob = await zip.generateAsync({type:"blob"});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(zipBlob);
        link.download = `ColorStringArt-${getFormattedDateTime()}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
    }
    
    // --- Run ---
    updateResolution(parseInt(resolutionSelector.value, 10));
    updateMonoLinesSliderMax();
    initializeCanvases();

    function addCustomColorPicker(color = null) {
        const defaultColors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff', '#000000', '#ff8800', '#8800ff'];
        
        const container = document.createElement('div');
        container.className = 'palette-swatch-container';

        const colorPicker = document.createElement('input');
        colorPicker.type = 'color';
        colorPicker.className = 'palette-swatch'; // Re-use styling
        colorPicker.value = color || defaultColors[customPalettePickerContainer.children.length % defaultColors.length];
        
        const removeBtn = document.createElement('span');
        removeBtn.className = 'remove-swatch-btn';
        removeBtn.innerHTML = '&times;';
        removeBtn.title = 'Remove color';
        removeBtn.onclick = () => {
            container.remove();
        };

        container.appendChild(colorPicker);
        container.appendChild(removeBtn);
        customPalettePickerContainer.appendChild(container);
    }

    function updateCustomPalettePickers() {
        customPalettePickerContainer.innerHTML = ''; // Clear existing
        const initialColors = ['#ff0000', '#00ff00', '#0000ff', '#000000', '#ffffff'];
        initialColors.forEach(color => addCustomColorPicker(color));
    }
});
</script>
</body>
</html>
